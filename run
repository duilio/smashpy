#!/usr/bin/env python

import sys
import argparse

from smash.board import Board, START_POSITION


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--fen', default=START_POSITION)

    subparsers = parser.add_subparsers(
        title='Commands', description='smash builtin commands')

    shell_parser = subparsers.add_parser('shell', help='Run smash shell')
    shell_parser.set_defaults(cmd=run_shell)
    
    gentables_parser = subparsers.add_parser('gentables', help='Generate static tables')
    gentables_parser.set_defaults(cmd=run_gentables)
    
    perft_parser = subparsers.add_parser('perft', help='Run perft')
    perft_parser.add_argument('depth', metavar='DEPTH', default=1, type=int,
                              nargs='?')
    perft_parser.set_defaults(cmd=run_perft)

    explore_parser = subparsers.add_parser(
        'explore', help='Run perft after first move generation')
    explore_parser.add_argument('depth', metavar='DEPTH', default=1, type=int,
                                nargs='?')
    explore_parser.set_defaults(cmd=run_explore)

    args = parser.parse_args()
    args.cmd(args)


def run_gentables(args):
    from smash.tools.gentables import gen_tables
    print gen_tables()
    

def run_perft(args):
    from smash.perft import perft

    board = Board(args.fen)
    print board
    print perft(board, args.depth, 0)


def run_explore(args):
    """Generate the first level of moves and then run perft.

    Useful for debugging if a perft result doesn't match.

    """
    from smash.movegen import gen_moves
    from smash.perft import perft
    
    board = Board(args.fen)

    for m in gen_moves(board):
        board.move(m)
        if board.is_legal():
            r = perft(board, args.depth, 0)
            print 'position fen %s' % board.fen()
            print 'perft %s' % args.depth
            print '# result: %s' % r
        board.undo()


def run_shell(args):
    """Open a python shell with some useful commands"""
    
    import code
    from itertools import izip_longest

    from smash.move import Move
    from smash.movegen import gen_moves
    from smash.base import squares
    from smash.perft import perft

    board = Board(args.fen)

    def move_helper(*args, **kwargs):
        if len(args) + len(kwargs) == 1:
            board.move(*args, **kwargs)
        else:
            m = Move(*args, **kwargs)
            board.move(m)
        show_helper()

    def undo_helper():
        board.undo()
        show_helper()

    def show_helper():
        print board
        print board.fen()

    def perft_helper(depth):
        print perft(board, depth, 0)

    def movelist_helper():
        r = []
        for m in gen_moves(board):
            board.move(m)
            if board.is_legal():
                r.append(m.str_simple())
            board.undo()
        r = iter(r)
        for row in izip_longest(*[r]*4, fillvalue=''):
            print ' '.join(row)

    imported_objects = dict(b=board,
                            move=move_helper,
                            undo=undo_helper,
                            fen=board.fen,
                            show=show_helper,
                            perft=perft_helper,
                            movelist=movelist_helper, )
    imported_objects.update(squares)

    try:
        import readline
    except ImportError:
        pass
    else:
        import rlcompleter
        readline.set_completer(
            rlcompleter.Completer(imported_objects).complete)
        readline.parse_and_bind('tab:complete')

    banner = """
smash %s
Shell interpreter.

%s
%s
""" % ('0.2', str(board), board.fen())
    code.interact(local=imported_objects, banner=banner.strip())

if __name__ == '__main__':
    sys.exit(main())
